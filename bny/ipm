#!/usr/bin/env bun
//
// bny ipm ‚Äî iteration planning meeting
//
// reads project context, launches an interactive claude session for planning.
// the human drives the conversation; claude has full project context.
//
// usage:
//   bny ipm               # interactive planning session
//   bny ipm --dry-run     # print system prompt, don't run
//

import { existsSync, readdirSync, mkdirSync } from "node:fs"
import { resolve } from "node:path"
import { find_root } from "./lib/feature.ts"
import { read_section, build_prompt } from "./lib/prompt.ts"

// -- parse args --

const argv = process.argv.slice(2)
let dry_run = false

for (const arg of argv) {
  if (arg === "--dry-run") {
    dry_run = true
  } else if (arg === "--help" || arg === "-h") {
    process.stdout.write("usage: bny ipm [--dry-run]\n")
    process.stdout.write("\nlaunches an interactive planning session with full project context.\n")
    process.stdout.write("when done, ask claude to write the roadmap to specs/ROADMAP.md.\n")
    process.exit(0)
  }
}

// -- gather context --

const root = find_root()

const context_files: [string, string][] = [
  ["README", "README.md"],
  ["Product Vision", "docs/product-vision.md"],
  ["Business Model", "docs/business-model.md"],
  ["Current Roadmap", "bny/roadmap.md"],
  ["Current ROADMAP", "specs/ROADMAP.md"],
]

const sections = context_files
  .map(([heading, rel]) => read_section(heading, resolve(root, rel)))
  .filter((s): s is NonNullable<typeof s> => s !== null)

// gather all existing specs
const specs_dir = resolve(root, "specs")
if (existsSync(specs_dir)) {
  const spec_dirs = readdirSync(specs_dir, { withFileTypes: true })
    .filter(e => e.isDirectory())
    .sort((a, b) => a.name.localeCompare(b.name))

  for (const dir of spec_dirs) {
    const spec_path = resolve(specs_dir, dir.name, "spec.md")
    const section = read_section(`Shipped: ${dir.name}`, spec_path)
    if (section) sections.push(section)
  }
}

if (sections.length === 0) {
  process.stderr.write("error: no project context files found\n")
  process.exitCode = 1
  process.exit()
}

// -- build system prompt --

const instructions = [
  "You are conducting an Iteration Planning Meeting (IPM) for this project.",
  "You have full context on what's been built (shipped specs) and the product vision.",
  "",
  "Start by presenting:",
  "1. Brief current state summary",
  "2. Key gaps between current state and vision",
  "3. Your proposed next 5-10 features, prioritized",
  "",
  "Then have a conversation with the human. They may:",
  "- Reprioritize features",
  "- Add/remove items",
  "- Ask questions about dependencies or scope",
  "- Challenge your reasoning",
  "",
  "When the human says they're done (or says 'write it' / 'ship it' / 'save'),",
  "write the final agreed roadmap to specs/ROADMAP.md with this format:",
  "",
  "## Current State",
  "## Gaps",
  "## Proposed Features (prioritized)",
  "Each feature: Title, Priority (P0/P1/P2), Description, Rationale",
  "",
  "Prioritize by: unblocking other work > user-facing value > technical debt.",
  "Be specific and actionable. No vague suggestions.",
].join("\n")

const prompt = build_prompt(sections, instructions)

// -- dry run --

if (dry_run) {
  process.stdout.write(prompt + "\n")
  process.exit(0)
}

// -- guards --

const claude_check = Bun.spawnSync(["which", "claude"], { stdout: "pipe", stderr: "pipe" })
if (claude_check.exitCode !== 0) {
  process.stderr.write("error: claude CLI not found on PATH\n")
  process.exitCode = 1
  process.exit()
}

// ensure specs dir exists
mkdirSync(resolve(root, "specs"), { recursive: true })

// -- write system prompt to temp file --

const tmp_prompt = resolve(root, ".bny", "ipm-prompt.md")
mkdirSync(resolve(root, ".bny"), { recursive: true })
await Bun.write(tmp_prompt, prompt)

// -- launch interactive claude --

process.stderr.write("\nüê∞ IPM session starting ‚Äî full project context loaded.\n")
process.stderr.write("   When done, tell claude to 'write it' and it'll save specs/ROADMAP.md.\n\n")

const proc = Bun.spawn([
  "claude",
  "--system-prompt", prompt,
  "--dangerously-skip-permissions",
], {
  stdout: "inherit",
  stderr: "inherit",
  stdin:  "inherit",
  cwd:    root,
})

const exit_code = await proc.exited
process.exitCode = exit_code
